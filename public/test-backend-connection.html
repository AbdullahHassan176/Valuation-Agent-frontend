<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backend Connection Test</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
        .test { margin: 10px 0; padding: 10px; border: 1px solid #333; border-radius: 5px; }
        .success { background: #0d4f0d; border-color: #4caf50; }
        .error { background: #4d0d0d; border-color: #f44336; }
        .info { background: #0d2d4d; border-color: #2196f3; }
        button { padding: 10px 20px; margin: 5px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; }
        button:hover { background: #0056b3; }
        button:active { transform: translateY(1px); }
        pre { background: #2a2a2a; padding: 10px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; }
        h1 { color: #4caf50; text-align: center; }
        h3 { margin-top: 0; color: #fff; }
        .button-group { text-align: center; margin: 20px 0; }
        .status-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }
        .status-success { background: #4caf50; }
        .status-error { background: #f44336; }
        .status-info { background: #2196f3; }
    </style>
</head>
<body>
    <h1>üîß Backend Connection Test</h1>
    <p>Testing connection to: <code>https://valuation-backend-api-cadmfqgxgzawa7fp.canadacentral-01.azurewebsites.net</code></p>
    <p><small>Page loaded at: <span id="timestamp"></span></small></p>
    
    <div id="results"></div>
    
    <div class="button-group">
    <button onclick="testConnection()">üß™ Test Backend Connection</button>
        <button onclick="testHealth()">üíö Test Health Check</button>
        <button onclick="testValuationRuns()">üìä Test Valuation Runs</button>
        <button onclick="testCreateRun()">‚ûï Test Create Run</button>
        <br>
        <button onclick="testGroqLLM()">ü§ñ Test Groq LLM Endpoint</button>
        <button onclick="testGroqConfig()">üîß Test Groq Configuration</button>
        <button onclick="testXVAOptions()">üìä Test XVA Options</button>
        <button onclick="testCreateRunWithXVA()">üí∞ Test Create Run with XVA</button>
    <button onclick="testAllEndpoints()">üîç Test All Endpoints</button>
        <button onclick="testBothServices()">üîÑ Test Both Services</button>
        <button onclick="testNewEndpoints()">üß™ Test New Endpoints</button>
        <button onclick="testDatabaseStatus()">üóÑÔ∏è Test Database Status</button>
        <button onclick="testEnvironmentDetection()">üåç Test Environment Detection</button>
    <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
    </div>

    <script>
        const BACKEND_URL = 'https://valuation-backend-api-cadmfqgxgzawa7fp.canadacentral-01.azurewebsites.net';
        const API_URL = 'https://valuation-backend-api-cadmfqgxgzawa7fp.canadacentral-01.azurewebsites.net';
        
        function addResult(title, content, type = 'info') {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = `test ${type}`;
            div.innerHTML = `<h3>${title}</h3><pre>${content}</pre>`;
            results.appendChild(div);
        }
        
        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }
        
        async function testConnection() {
            addResult('üîç Testing Basic Connection', 'Testing GET / endpoint...', 'info');
            
            try {
                const response = await fetch(BACKEND_URL + '/');
                const data = await response.json();
                
                if (response.ok) {
                    addResult('‚úÖ Basic Connection Success', JSON.stringify(data, null, 2), 'success');
                } else {
                    addResult('‚ùå Basic Connection Failed', `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 'error');
                }
            } catch (error) {
                addResult('‚ùå Connection Error', `Error: ${error.message}`, 'error');
            }
        }
        
        async function testHealth() {
            addResult('üíö Testing Health Check', 'Testing GET /healthz endpoint...', 'info');
            
            try {
                const response = await fetch(BACKEND_URL + '/healthz');
                const data = await response.json();
                
                if (response.ok) {
                    addResult('‚úÖ Health Check Success', JSON.stringify(data, null, 2), 'success');
                } else {
                    addResult('‚ùå Health Check Failed', `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 'error');
                }
            } catch (error) {
                addResult('‚ùå Health Check Error', `Error: ${error.message}`, 'error');
            }
        }
        
        async function testValuationRuns() {
            addResult('üìä Testing Valuation Runs', 'Testing GET /api/valuation/runs endpoint...', 'info');
            
            try {
                const response = await fetch(BACKEND_URL + '/api/valuation/runs');
                const data = await response.json();
                
                if (response.ok) {
                    addResult('‚úÖ Valuation Runs Success', `Found ${data.length} runs:\n${JSON.stringify(data, null, 2)}`, 'success');
                } else {
                    addResult('‚ùå Valuation Runs Failed', `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 'error');
                }
            } catch (error) {
                addResult('‚ùå Valuation Runs Error', `Error: ${error.message}`, 'error');
            }
        }
        
        async function testCreateRun() {
            addResult('‚ûï Testing Create Run', 'Testing POST /api/valuation/runs endpoint...', 'info');
            
            const testRun = {
                spec: {
                    type: "IRS",
                    ccy: "USD",
                    notional: 1000000,
                    effective: "2024-01-15",
                    maturity: "2029-01-15",
                    fixedRate: 4.25,
                    floatIndex: "SOFR-3M"
                },
                asOf: "2024-01-15",
                marketDataProfile: "default",
                approach: ["OIS_discounting"]
            };
            
            try {
                const response = await fetch(BACKEND_URL + '/api/valuation/runs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(testRun)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    addResult('‚úÖ Create Run Success', `Run created with ID: ${data.id || data.run_id}\n${JSON.stringify(data, null, 2)}`, 'success');
                } else {
                    addResult('‚ùå Create Run Failed', `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 'error');
                }
            } catch (error) {
                addResult('‚ùå Create Run Error', `Error: ${error.message}`, 'error');
            }
        }
        
        async function testGroqLLM() {
            addResult('ü§ñ Testing Groq LLM Endpoint', 'Testing POST /poc/chat endpoint with Groq LLM...', 'info');
            
            try {
                const response = await fetch(BACKEND_URL + '/poc/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ message: 'Hello! This is a test message for Groq LLM. Can you tell me about XVA calculations?' })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const llmInfo = data.llm_powered ? '‚úÖ Powered by Groq LLM' : '‚ö†Ô∏è Using fallback responses';
                    const modelInfo = data.model ? `\nModel: ${data.model}` : '';
                    const fallbackInfo = data.fallback ? '\n‚ö†Ô∏è FALLBACK MODE' : '';
                    
                    addResult('‚úÖ Groq LLM Endpoint Success', 
                        `${llmInfo}${modelInfo}${fallbackInfo}\n\nResponse: ${JSON.stringify(data, null, 2)}`, 
                        'success');
                } else {
                    addResult('‚ùå Groq LLM Endpoint Failed', `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 'error');
                }
            } catch (error) {
                addResult('‚ùå Groq LLM Error', `Error: ${error.message}`, 'error');
            }
        }
        
        async function testGroqConfig() {
            addResult('üîß Testing Groq Configuration', 'Testing Groq LLM configuration and availability...', 'info');
            
            try {
                // First test the Groq configuration endpoint
                const configResponse = await fetch(BACKEND_URL + '/api/test/groq-config');
                const configData = await configResponse.json();
                
                if (configResponse.ok) {
                    const configAnalysis = `
Groq Configuration Status:
- Groq Configured: ${configData.groq_configured ? '‚úÖ YES' : '‚ùå NO'}
- API Key Present: ${configData.api_key_present ? '‚úÖ YES' : '‚ùå NO'}
- Base URL: ${configData.groq_base_url}
- Model: ${configData.groq_model}
- Use Groq: ${configData.use_groq ? '‚úÖ YES' : '‚ùå NO'}
- API Key Preview: ${configData.api_key_preview}

Full Config: ${JSON.stringify(configData, null, 2)}`;
                    
                    addResult('‚úÖ Groq Configuration Status', configAnalysis, 'success');
                } else {
                    addResult('‚ùå Groq Configuration Endpoint Failed', `Status: ${configResponse.status}\nResponse: ${JSON.stringify(configData, null, 2)}`, 'error');
                }
                
                // Then test with a specific Groq-focused message
                const chatResponse = await fetch(BACKEND_URL + '/poc/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        message: 'What is your name and what LLM are you using? Please be specific about the model.' 
                    })
                });
                
                const chatData = await chatResponse.json();
                
                if (chatResponse.ok) {
                    const chatAnalysis = `
Groq LLM Test Results:
- LLM Powered: ${chatData.llm_powered ? '‚úÖ YES' : '‚ùå NO'}
- Model: ${chatData.model || 'Unknown'}
- Version: ${chatData.version || 'Unknown'}
- Fallback Mode: ${chatData.fallback ? '‚ö†Ô∏è YES' : '‚úÖ NO'}
- Response Length: ${chatData.response ? chatData.response.length : 0} characters

Response Preview: ${chatData.response ? chatData.response.substring(0, 200) + '...' : 'No response'}

Full Chat Response: ${JSON.stringify(chatData, null, 2)}`;
                    
                    addResult('‚úÖ Groq LLM Test Results', chatAnalysis, 'success');
                } else {
                    addResult('‚ùå Groq Chat Test Failed', `Status: ${chatResponse.status}\nResponse: ${JSON.stringify(chatData, null, 2)}`, 'error');
                }
            } catch (error) {
                addResult('‚ùå Groq Configuration Error', `Error: ${error.message}`, 'error');
            }
        }
        
        async function testXVAOptions() {
            addResult('üìä Testing XVA Options', 'Testing XVA calculation options endpoint...', 'info');
            
            try {
                const response = await fetch(BACKEND_URL + '/api/valuation/xva-options');
                const data = await response.json();
                
                if (response.ok) {
                    const analysis = `
XVA Options Available:
- QuantLib Available: ${data.quantlib_available ? '‚úÖ YES' : '‚ùå NO'}
- Available Components: ${Object.keys(data.available_xva_components).join(', ')}
- Default IRS Selection: ${data.default_selections.IRS.join(', ')}
- Default CCS Selection: ${data.default_selections.CCS.join(', ')}

Full Response: ${JSON.stringify(data, null, 2)}`;
                    
                    addResult('‚úÖ XVA Options Test', analysis, 'success');
                } else {
                    addResult('‚ùå XVA Options Failed', `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 'error');
                }
            } catch (error) {
                addResult('‚ùå XVA Options Error', `Error: ${error.message}`, 'error');
            }
        }
        
        async function testCreateRunWithXVA() {
            addResult('üí∞ Testing Create Run with XVA', 'Testing run creation with XVA calculations...', 'info');
            
            try {
                const runRequest = {
                    asOf: new Date().toISOString().split('T')[0],
                    spec: {
                        ccy: "USD",
                        notional: 10000000,
                        fixedRate: 0.035,
                        effective: "2024-01-01",
                        maturity: "2029-01-01",
                        counterparty_rating: "BBB",
                        own_rating: "AA",
                        funding_rate: 0.025,
                        capital_ratio: 0.12,
                        margin_rate: 0.015
                    },
                    xva_selection: ["CVA", "DVA", "FVA", "KVA", "MVA"]
                };
                
                const response = await fetch(BACKEND_URL + '/api/valuation/runs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(runRequest)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    const analysis = `
XVA Run Creation Success:
- Run ID: ${data.id}
- PV Base CCY: $${data.pv_base_ccy}
- XVA Selection: ${data.xva_selection ? data.xva_selection.join(', ') : 'None'}
- QuantLib Used: ${data.calculation_details?.method === 'quantlib_advanced' ? '‚úÖ YES' : '‚ùå NO'}
- XVA Components: ${data.xva_analysis?.xva_components ? Object.keys(data.xva_analysis.xva_components).join(', ') : 'None'}

Full Response: ${JSON.stringify(data, null, 2)}`;
                    
                    addResult('‚úÖ XVA Run Creation Success', analysis, 'success');
                } else {
                    addResult('‚ùå XVA Run Creation Failed', `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 'error');
                }
            } catch (error) {
                addResult('‚ùå XVA Run Creation Error', `Error: ${error.message}`, 'error');
            }
        }
        
        async function testEnvironmentDetection() {
            addResult('üåç Testing Environment Detection', 'Testing frontend environment detection logic...', 'info');
            
            const envInfo = {
                hostname: window.location.hostname,
                href: window.location.href,
                isLocalhost: ['localhost', '127.0.0.1'].includes(window.location.hostname),
                isAzure: window.location.hostname.includes('azurestaticapps.net'),
                isProduction: !['localhost', '127.0.0.1'].includes(window.location.hostname),
                userAgent: navigator.userAgent,
                protocol: window.location.protocol
            };
            
            const expectedBackend = envInfo.isLocalhost 
                ? 'http://localhost:8000' 
                : 'https://valuation-backend-api-cadmfqgxgzawa7fp.canadacentral-01.azurewebsites.net';
            
            addResult('‚úÖ Environment Detection', 
                `Environment Info:\n${JSON.stringify(envInfo, null, 2)}\n\nExpected Backend: ${expectedBackend}`, 
                'success');
        }
        
        async function testBothServices() {
            addResult('üîÑ Testing Both Services', 'Testing Backend and API services...', 'info');
            
            // Test Backend Service (LangGraph Orchestrator)
            try {
                const backendResponse = await fetch(BACKEND_URL + '/healthz');
                const backendData = await backendResponse.json();
                
                if (backendResponse.ok) {
                    addResult('‚úÖ Backend Service (LangGraph)', 
                        `Status: ${backendResponse.status}\nResponse: ${JSON.stringify(backendData, null, 2)}`, 
                        'success');
                } else {
                    addResult('‚ùå Backend Service (LangGraph)', 
                        `Status: ${backendResponse.status}\nResponse: ${JSON.stringify(backendData, null, 2)}`, 
                        'error');
                }
            } catch (error) {
                addResult('‚ùå Backend Service (LangGraph)', `Error: ${error.message}`, 'error');
            }
            
            // Test API Service (Valuation Engine)
            try {
                const apiResponse = await fetch(API_URL + '/healthz');
                const apiData = await apiResponse.json();
                
                if (apiResponse.ok) {
                    addResult('‚úÖ API Service (Valuation)', 
                        `Status: ${apiResponse.status}\nResponse: ${JSON.stringify(apiData, null, 2)}`, 
                        'success');
                } else {
                    addResult('‚ùå API Service (Valuation)', 
                        `Status: ${apiResponse.status}\nResponse: ${JSON.stringify(apiData, null, 2)}`, 
                        'error');
                }
            } catch (error) {
                addResult('‚ùå API Service (Valuation)', `Error: ${error.message}`, 'error');
            }
        }

        async function testNewEndpoints() {
            addResult('üß™ Testing New Endpoints', 'Testing the newly implemented POC endpoints...', 'info');
            
            // Test IFRS Ask
            try {
                const response = await fetch(BACKEND_URL + '/poc/ifrs-ask', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question: 'What is fair value measurement under IFRS 13?' })
                });
                const data = await response.json();
                
                if (response.ok) {
                    addResult('‚úÖ IFRS Ask', 
                        `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 
                        'success');
                } else {
                    addResult('‚ùå IFRS Ask', 
                        `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 
                        'error');
                }
            } catch (error) {
                addResult('‚ùå IFRS Ask', `Error: ${error.message}`, 'error');
            }
            
            // Test Parse Contract
            try {
                const response = await fetch(BACKEND_URL + '/poc/parse-contract', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text: 'This is a sample interest rate swap contract with a notional amount of $10 million and a maturity of 5 years.' 
                    })
                });
                const data = await response.json();
                
                if (response.ok) {
                    addResult('‚úÖ Parse Contract', 
                        `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 
                        'success');
                } else {
                    addResult('‚ùå Parse Contract', 
                        `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 
                        'error');
                }
            } catch (error) {
                addResult('‚ùå Parse Contract', `Error: ${error.message}`, 'error');
            }
            
            // Test Explain Run
            try {
                const response = await fetch(BACKEND_URL + '/poc/explain-run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ run_id: 'test-run-001' })
                });
                const data = await response.json();
                
                if (response.ok) {
                    addResult('‚úÖ Explain Run', 
                        `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 
                        'success');
                } else {
                    addResult('‚ùå Explain Run', 
                        `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 
                        'error');
                }
            } catch (error) {
                addResult('‚ùå Explain Run', `Error: ${error.message}`, 'error');
            }
            
            // Test Curves
            try {
                const response = await fetch(BACKEND_URL + '/api/valuation/curves');
                const data = await response.json();
                
                if (response.ok) {
                    addResult('‚úÖ Curves', 
                        `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 
                        'success');
                } else {
                    addResult('‚ùå Curves', 
                        `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 
                        'error');
                }
            } catch (error) {
                addResult('‚ùå Curves', `Error: ${error.message}`, 'error');
            }
        }

        async function testDatabaseStatus() {
            addResult('üóÑÔ∏è Testing Database Status', 'Checking database persistence and data...', 'info');
            
            try {
                const response = await fetch(BACKEND_URL + '/api/database/status');
                const data = await response.json();
                
                if (response.ok) {
                    addResult('‚úÖ Database Status', 
                        `Database Type: ${data.database_type}\n` +
                        `Database Path: ${data.database_path}\n` +
                        `Total Runs: ${data.total_runs}\n` +
                        `Total Curves: ${data.total_curves}\n` +
                        `Recent Runs: ${JSON.stringify(data.recent_runs, null, 2)}\n` +
                        `Message: ${data.message}`, 
                        'success');
                } else {
                    addResult('‚ùå Database Status', 
                        `Status: ${response.status}\nResponse: ${JSON.stringify(data, null, 2)}`, 
                        'error');
                }
            } catch (error) {
                addResult('‚ùå Database Status', `Error: ${error.message}`, 'error');
            }
        }
        
        async function testAllEndpoints() {
            const endpoints = [
                { name: 'Health Check', url: '/healthz', method: 'GET' },
                { name: 'API Info', url: '/', method: 'GET' },
                { name: 'Valuation Runs (GET)', url: '/api/valuation/runs', method: 'GET' },
                { name: 'Curves', url: '/api/valuation/curves', method: 'GET' },
                { name: 'Chat (GET)', url: '/poc/chat', method: 'GET' },
                { name: 'IFRS Ask', url: '/poc/ifrs-ask', method: 'POST', data: { question: 'What is fair value measurement under IFRS 13?' } },
                { name: 'Parse Contract', url: '/poc/parse-contract', method: 'POST', data: { text: 'This is a sample interest rate swap contract with a notional amount of $10 million and a maturity of 5 years.' } },
                { name: 'Explain Run', url: '/poc/explain-run', method: 'POST', data: { run_id: 'test-run-001' } }
            ];
            
            addResult('üîç Testing All Endpoints', 'Running comprehensive endpoint tests...', 'info');
            
            for (const endpoint of endpoints) {
                try {
                    const options = {
                        method: endpoint.method,
                        headers: { 'Content-Type': 'application/json' }
                    };
                    
                    if (endpoint.method === 'POST') {
                        options.body = JSON.stringify(endpoint.data || { message: 'Test message' });
                    }
                    
                    const response = await fetch(BACKEND_URL + endpoint.url, options);
                    
                    // Try to parse as JSON, but handle non-JSON responses
                    let data;
                    try {
                        data = await response.json();
                    } catch (e) {
                        data = await response.text();
                    }
                    
                    if (response.ok) {
                        addResult(`‚úÖ ${endpoint.name}`, 
                            typeof data === 'string' ? data : JSON.stringify(data, null, 2), 
                            'success');
                    } else {
                        addResult(`‚ùå ${endpoint.name}`, 
                            `Status: ${response.status}\nResponse: ${typeof data === 'string' ? data : JSON.stringify(data, null, 2)}`, 
                            'error');
                    }
                } catch (error) {
                    addResult(`‚ùå ${endpoint.name}`, `Error: ${error.message}`, 'error');
                }
            }
        }
        
        // Auto-run basic tests on page load
        window.onload = function() {
            // Set timestamp
            document.getElementById('timestamp').textContent = new Date().toLocaleString();
            
            addResult('üöÄ Page Loaded', 'Running automatic tests...', 'info');
            
            // Auto-run environment detection and health check
            setTimeout(() => {
                testEnvironmentDetection();
            }, 500);
            
            setTimeout(() => {
                testHealth();
            }, 1000);
            
            setTimeout(() => {
                testConnection();
            }, 1500);
        };
    </script>
</body>
</html>
